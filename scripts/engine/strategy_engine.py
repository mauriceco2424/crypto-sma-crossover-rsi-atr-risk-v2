"""
Strategy Engine Template

This file will be generated by /build-engine based on the strategy template.
It contains the specific strategy implementation.
"""

from typing import Dict, Any, List, Optional
from datetime import datetime
import pandas as pd
import numpy as np

from .core.strategy_interface import StrategyInterface


class GeneratedStrategy(StrategyInterface):
    """
    Generated strategy implementation.
    
    This class will be auto-generated by the /build-engine command
    based on the strategy template and requirements.
    """
    
    def __init__(self, parameters: Dict[str, Any]):
        """
        Initialize strategy with parameters.
        
        Args:
            parameters: Strategy parameters from parameter_config.md
        """
        super().__init__(parameters)
        
        # Strategy-specific parameters (will be generated)
        # Example parameters:
        self.rsi_period = parameters.get('rsi_period', 14)
        self.rsi_oversold = parameters.get('rsi_oversold', 30)
        self.rsi_overbought = parameters.get('rsi_overbought', 70)
        self.sma_fast = parameters.get('sma_fast', 10)
        self.sma_slow = parameters.get('sma_slow', 20)
        self.position_size_pct = parameters.get('position_size_pct', 2.0)
        
        # Strategy state
        self.last_signals = {}
        self.position_counts = {}
        
    def generate_signals(self, 
                        current_time: datetime,
                        ohlcv_data: Dict[str, pd.DataFrame],
                        features: Dict[str, pd.DataFrame],
                        portfolio_state: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Generate trading signals based on strategy logic.
        
        This method will be auto-generated based on strategy template.
        """
        signals = []
        
        # Example strategy logic (will be replaced by generated code)
        for symbol, ohlcv_df in ohlcv_data.items():
            if symbol not in features or features[symbol].empty:
                continue
            
            try:
                # Get current data point
                if current_time not in ohlcv_df.index:
                    continue
                
                current_bar = ohlcv_df.loc[current_time]
                current_features = features[symbol].loc[current_time]
                
                # Example: RSI + SMA crossover strategy
                rsi = current_features.get('rsi_14')
                sma_fast = current_features.get('sma_10')
                sma_slow = current_features.get('sma_20')
                
                if pd.isna(rsi) or pd.isna(sma_fast) or pd.isna(sma_slow):
                    continue
                
                # Check current position
                current_position = portfolio_state.get('positions', {}).get(symbol, {})
                has_position = current_position.get('quantity', 0) != 0
                
                # Buy signal: RSI oversold + fast SMA > slow SMA
                if (rsi < self.rsi_oversold and 
                    sma_fast > sma_slow and 
                    not has_position):
                    
                    signals.append({
                        'symbol': symbol,
                        'action': 'buy',
                        'order_type': 'market',
                        'metadata': {
                            'rsi': rsi,
                            'sma_fast': sma_fast,
                            'sma_slow': sma_slow,
                            'signal_strength': (self.rsi_oversold - rsi) / self.rsi_oversold
                        }
                    })
                
                # Sell signal: RSI overbought or fast SMA < slow SMA
                elif has_position and (rsi > self.rsi_overbought or sma_fast < sma_slow):
                    
                    signals.append({
                        'symbol': symbol,
                        'action': 'close',
                        'order_type': 'market',
                        'metadata': {
                            'rsi': rsi,
                            'sma_fast': sma_fast,
                            'sma_slow': sma_slow,
                            'exit_reason': 'overbought' if rsi > self.rsi_overbought else 'trend_change'
                        }
                    })
                
            except Exception as e:
                # Log error but continue with other symbols
                continue
        
        return signals
    
    def calculate_position_size(self,
                              signal: Dict[str, Any],
                              portfolio_state: Dict[str, Any],
                              current_price: float) -> float:
        """
        Calculate position size for a signal.
        
        This method will be auto-generated based on strategy template.
        """
        try:
            total_equity = portfolio_state.get('total_equity', 100000)
            
            # Position sizing based on percentage of equity
            position_value = total_equity * (self.position_size_pct / 100)
            quantity = position_value / current_price
            
            return quantity
            
        except Exception as e:
            return 0.0
    
    def get_required_features(self) -> List[str]:
        """
        Return list of required feature names.
        
        This will be auto-generated based on strategy requirements.
        """
        return [
            'rsi_14',
            'sma_10',
            'sma_20'
        ]
    
    def get_warmup_periods(self) -> int:
        """
        Return number of periods needed for strategy warmup.
        
        This will be auto-generated based on maximum lookback period.
        """
        # Return the maximum lookback needed for indicators
        return max(self.rsi_period, self.sma_slow) + 10  # Add buffer
    
    def validate_parameters(self) -> bool:
        """Validate strategy parameters."""
        errors = []
        
        # Validate RSI parameters
        if not (1 <= self.rsi_period <= 100):
            errors.append("rsi_period must be between 1 and 100")
        
        if not (0 < self.rsi_oversold < self.rsi_overbought < 100):
            errors.append("RSI thresholds must be: 0 < oversold < overbought < 100")
        
        # Validate SMA parameters
        if not (1 <= self.sma_fast < self.sma_slow <= 200):
            errors.append("SMA periods must be: 1 <= fast < slow <= 200")
        
        # Validate position size
        if not (0.1 <= self.position_size_pct <= 10.0):
            errors.append("position_size_pct must be between 0.1% and 10%")
        
        if errors:
            for error in errors:
                print(f"Parameter validation error: {error}")
            return False
        
        return True
    
    def on_trade_filled(self, 
                       fill_info: Dict[str, Any],
                       portfolio_state: Dict[str, Any]) -> None:
        """Called when a trade is filled."""
        symbol = fill_info['symbol']
        action = fill_info['action']
        
        # Update position tracking
        if symbol not in self.position_counts:
            self.position_counts[symbol] = 0
        
        if action in ['buy', 'long']:
            self.position_counts[symbol] += 1
        elif action in ['sell', 'close']:
            self.position_counts[symbol] = max(0, self.position_counts[symbol] - 1)
    
    def on_bar_close(self,
                    current_time: datetime,
                    ohlcv_data: Dict[str, pd.DataFrame],
                    portfolio_state: Dict[str, Any]) -> None:
        """Called at the end of each bar."""
        # Can be used for state management, logging, etc.
        pass