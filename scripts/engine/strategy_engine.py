"""
Crypto SMA Crossover + RSI + ATR Risk Strategy Engine

This strategy implements a trend-following approach using:
- SMA(50/200) crossover for trend identification
- RSI(14) > 50 for momentum confirmation  
- Top 20% relative strength ranking for quality filtering
- ATR-based risk management with trailing stops
- Hardware-optimized execution with FilterGateManager, DataProcessor caching, and ReferenceEngine

Generated by /build-engine command based on SMR specifications.
"""

from typing import Dict, Any, List, Optional, Set
from datetime import datetime
import pandas as pd
import numpy as np
import logging

# Import optimization components
try:
    from .core.strategy_interface import StrategyInterface
    from .core.filter_gate_manager import FilterGateManager
    from .data.data_processor import DataProcessor
    from .optimization.reference_engine import ReferenceEngine
except (ImportError, SystemError):
    try:
        from core.strategy_interface import StrategyInterface
        from core.filter_gate_manager import FilterGateManager
        from data.data_processor import DataProcessor
        from optimization.reference_engine import ReferenceEngine
    except (ImportError, ModuleNotFoundError):
        # Fallback for testing - create minimal interfaces
        from typing import Dict, Any, List
        
        class StrategyInterface:
            def __init__(self, params=None):
                pass
        
        class FilterGateManager:
            def __init__(self):
                pass
            def register_common_filters(self):
                pass
        
        class DataProcessor:
            def __init__(self, config=None, enable_optimization=True, cache_size_mb=4800):
                self.config = config or {}
        
        class ReferenceEngine:
            def __init__(self):
                pass
            def is_initialized(self):
                return False
            def reduce_universe(self, data):
                return data

logger = logging.getLogger(__name__)


class GeneratedStrategy(StrategyInterface):
    """
    Crypto SMA Crossover + RSI + ATR Risk Strategy
    
    Hardware-optimized implementation with automatic speed optimizations.
    """
    
    # Strategy Parameters (from SMR)
    STRATEGY_PARAMS = {
        # Liquidity and Data Requirements
        'LIQUIDITY_THRESHOLD': 250000,  # USDT daily volume
        'MIN_BARS_REQUIRED': 365,       # Minimum history needed
        
        # Trend and Momentum Filters
        'TREND_SMA_PERIOD': 200,        # Long-term trend SMA
        'RSI_PERIOD': 14,                # RSI period
        'RSI_THRESHOLD': 50,             # RSI minimum value
        
        # Relative Strength Ranking
        'RS_LOOKBACK': 90,               # Days for relative strength
        'RS_PERCENTILE': 0.80,           # Top 20% (80th percentile)
        'RS_MIN_SYMBOLS': 40,            # Minimum symbols in shortlist
        
        # SMA Crossover Parameters
        'FAST_SMA': 50,                  # Fast SMA period
        'SLOW_SMA': 200,                 # Slow SMA period
        'VOLUME_MULTIPLIER': 1.2,        # Volume confirmation threshold
        'VOLUME_LOOKBACK': 20,           # Volume average period
        
        # Risk Management (ATR-based)
        'ATR_PERIOD': 14,                # ATR period for stops
        'INITIAL_STOP_ATR_MULT': 2.0,   # Initial stop distance in ATRs
        'TRAILING_STOP_ATR_MULT': 3.0,  # Trailing stop distance in ATRs
        'TAKE_PROFIT_R_MULT': 3.0,       # Take profit in R multiples
        'MAX_HOLDING_DAYS': 90,          # Maximum position hold time
        
        # Portfolio Management
        'RISK_PER_TRADE': 0.0075,        # 0.75% risk per trade
        'MAX_CONCURRENT_POSITIONS': 30,  # Maximum open positions
        'MAX_WEIGHT_PER_SYMBOL': 0.10,   # 10% concentration limit
        'DAILY_DEPLOY_CAP': 0.20,        # 20% daily capital deployment
        'COOLDOWN_BARS': 7,              # Bars before re-entry
        
        # Optional Breadth Filter (default OFF)
        'USE_BREADTH_FILTER': False,     # BTC trend filter
        'BREADTH_SYMBOL': 'BTC/USDT',    # Breadth gauge symbol
    }
    
    def __init__(self, parameters: Dict[str, Any] = None):
        """Initialize strategy with hardware-optimized components."""
        super().__init__(parameters or {})
        
        # Merge config with defaults
        self.config = self.STRATEGY_PARAMS.copy()
        if parameters:
            self.config.update(parameters)
        
        # Initialize optimization components for maximum speed
        self.filter_gate_manager = FilterGateManager()
        self.filter_gate_manager.register_common_filters()
        
        # Data processor with feature caching and dependency optimization
        processor_config = self.config.copy()
        processor_config['enable_feature_optimization'] = True
        processor_config['cache_size_mb'] = 4800  # 4.8GB cache for this hardware
        self.data_processor = DataProcessor(processor_config)
        
        # Reference engine for universe reduction
        self.reference_engine = ReferenceEngine()
        
        # Strategy state tracking
        self.positions = {}  # Active positions by symbol
        self.exit_cooldowns = {}  # Cooldown tracking
        self.daily_deployed = 0  # Daily capital deployed
        self.last_deployment_date = None
        self.highest_prices = {}  # Track highest price for trailing stop
        
        # Performance tracking
        self.signal_counts = {'entry': 0, 'exit': 0, 'filtered': 0}
        self.cache_hits = 0
        self.cache_misses = 0
        
        logger.info(f"Strategy initialized with {len(self.config)} parameters")
        logger.info("Hardware optimizations enabled: FilterGateManager, DataProcessor caching, ReferenceEngine")
        
    def generate_signals(self, 
                        current_time: datetime,
                        ohlcv_data: Dict[str, pd.DataFrame],
                        features: Dict[str, pd.DataFrame],
                        portfolio_state: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Main signal generation method with full optimization.
        
        Process:
        1. Apply universe filters
        2. Calculate features for all symbols
        3. Rank by relative strength
        4. Check for entry/exit signals
        5. Size positions appropriately
        """
        signals = []
        
        # Use ReferenceEngine to reduce universe for optimization
        if self.reference_engine and hasattr(self.reference_engine, 'is_initialized'):
            if self.reference_engine.is_initialized():
                ohlcv_data = self.reference_engine.reduce_universe(ohlcv_data)
        
        # Apply universe filters
        filtered_universe = self.apply_universe_filters(ohlcv_data, current_time)
        
        if not filtered_universe:
            return signals
        
        # Calculate features for all symbols (with caching)
        universe_with_features = {}
        for symbol in filtered_universe:
            if symbol in features and not features[symbol].empty:
                universe_with_features[symbol] = features[symbol]
        
        # Calculate relative strength ranking
        rs_shortlist = self.calculate_relative_strength_ranking(
            universe_with_features, current_time
        )
        
        # Check existing positions for exits first (priority)
        for symbol in list(self.positions.keys()):
            if symbol in universe_with_features:
                exit_signal = self.check_exit_signals(
                    symbol,
                    current_time,
                    universe_with_features[symbol],
                    ohlcv_data[symbol]
                )
                if exit_signal:
                    signals.append(exit_signal)
                    # Mark for cooldown
                    self.exit_cooldowns[symbol] = current_time
        
        # Check for new entries (only if we have capacity)
        current_positions = len(self.positions)
        equity = portfolio_state.get('total_equity', 100000)
        
        # Check daily deployment cap
        current_date = current_time.date() if hasattr(current_time, 'date') else current_time
        if self.last_deployment_date != current_date:
            self.daily_deployed = 0
            self.last_deployment_date = current_date
        
        for symbol in filtered_universe:
            if symbol in self.positions:
                continue  # No pyramiding
            
            if current_positions >= self.config['MAX_CONCURRENT_POSITIONS']:
                break  # Position limit reached
            
            entry_signal = self.check_entry_signals(
                symbol,
                current_time,
                universe_with_features.get(symbol),
                ohlcv_data[symbol],
                rs_shortlist
            )
            
            if entry_signal:
                position_size = self.calculate_position_size(
                    entry_signal, 
                    equity,
                    ohlcv_data[symbol]
                )
                
                if position_size > 0:
                    entry_signal['quantity'] = position_size
                    signals.append(entry_signal)
                    current_positions += 1
                    self.daily_deployed += position_size * entry_signal.get('price', 0)
        
        return signals
    
    def calculate_position_size(self,
                              signal: Dict[str, Any],
                              portfolio_state: Dict[str, Any],
                              current_price: float) -> float:
        """
        Calculate position size for a signal.
        
        This method will be auto-generated based on strategy template.
        """
        try:
            total_equity = portfolio_state.get('total_equity', 100000)
            
            # Position sizing based on percentage of equity
            position_value = total_equity * (self.position_size_pct / 100)
            quantity = position_value / current_price
            
            return quantity
            
        except Exception as e:
            return 0.0
    
    def get_required_features(self) -> List[str]:
        """
        Return list of required feature names.
        
        This will be auto-generated based on strategy requirements.
        """
        return [
            'rsi_14',
            'sma_10',
            'sma_20'
        ]
    
    def get_warmup_periods(self) -> int:
        """
        Return number of periods needed for strategy warmup.
        """
        # Maximum of: SMA(200), RS lookback (90), min bars (365)
        return max(
            self.config['MIN_BARS_REQUIRED'],
            self.config['SLOW_SMA'],
            self.config['RS_LOOKBACK']
        ) + 10  # Add buffer
    
    def validate_parameters(self) -> bool:
        """Validate strategy parameters."""
        errors = []
        
        # Validate SMA parameters
        if self.config['FAST_SMA'] >= self.config['SLOW_SMA']:
            errors.append("FAST_SMA must be less than SLOW_SMA")
        
        # Validate RSI parameters
        if not (0 < self.config['RSI_THRESHOLD'] < 100):
            errors.append("RSI_THRESHOLD must be between 0 and 100")
        
        # Validate ATR multipliers
        if self.config['INITIAL_STOP_ATR_MULT'] <= 0:
            errors.append("INITIAL_STOP_ATR_MULT must be positive")
        
        if self.config['TRAILING_STOP_ATR_MULT'] <= 0:
            errors.append("TRAILING_STOP_ATR_MULT must be positive")
        
        # Validate risk parameters
        if not (0.001 <= self.config['RISK_PER_TRADE'] <= 0.05):
            errors.append("RISK_PER_TRADE must be between 0.1% and 5%")
        
        if not (1 <= self.config['MAX_CONCURRENT_POSITIONS'] <= 100):
            errors.append("MAX_CONCURRENT_POSITIONS must be between 1 and 100")
        
        # Validate data requirements
        if self.config['MIN_BARS_REQUIRED'] < self.config['SLOW_SMA']:
            errors.append("MIN_BARS_REQUIRED must be >= SLOW_SMA period")
        
        if errors:
            for error in errors:
                logger.error(f"Parameter validation error: {error}")
            return False
        
        return True
    
    def on_trade_filled(self, 
                       fill_info: Dict[str, Any],
                       portfolio_state: Dict[str, Any]) -> None:
        """Called when a trade is filled."""
        symbol = fill_info['symbol']
        action = fill_info['action']
        
        # Update position tracking
        if symbol not in self.position_counts:
            self.position_counts[symbol] = 0
        
        if action in ['buy', 'long']:
            self.position_counts[symbol] += 1
        elif action in ['sell', 'close']:
            self.position_counts[symbol] = max(0, self.position_counts[symbol] - 1)
    
    def on_bar_close(self,
                    current_time: datetime,
                    ohlcv_data: Dict[str, pd.DataFrame],
                    portfolio_state: Dict[str, Any]) -> None:
        """Called at the end of each bar."""
        # Can be used for state management, logging, etc.
        pass