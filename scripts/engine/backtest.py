"""
Main Backtest Engine

This is the main entry point for backtest execution, generated by /build-engine.
It coordinates all components to run a complete backtest simulation.
"""

import os
import sys
import json
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional
import logging

from .core.strategy_interface import StrategyInterface
from .core.portfolio_manager import PortfolioManager
from .core.order_manager import OrderManager
from .core.risk_manager import RiskManager
from .data.data_fetcher import DataFetcher
from .data.data_processor import DataProcessor
from .execution.fill_simulator import FillSimulator
from .execution.fee_calculator import FeeCalculator
from .execution.timing_engine import TimingEngine
from .utils.config_parser import ConfigParser
from .utils.progress_tracker import ProgressTracker
from .utils.validators import DataValidator

# This will be generated by /build-engine based on strategy template
from .strategy_engine import GeneratedStrategy


class BacktestEngine:
    """
    Main backtest execution engine.
    
    Orchestrates all components to run a complete backtest simulation with
    realistic timing, fees, slippage, and risk management.
    """
    
    def __init__(self, config_path: str = "parameter_config.md"):
        """
        Initialize backtest engine with configuration.
        
        Args:
            config_path: Path to parameter configuration file
        """
        self.logger = self._setup_logging()
        self.config_parser = ConfigParser()
        self.config = self.config_parser.parse_config(config_path)
        
        # Initialize components
        self.data_fetcher = DataFetcher(self.config)
        self.data_processor = DataProcessor(self.config)
        self.portfolio_manager = PortfolioManager(self.config)
        self.order_manager = OrderManager(self.config)
        self.risk_manager = RiskManager(self.config)
        self.fill_simulator = FillSimulator(self.config)
        self.fee_calculator = FeeCalculator(self.config)
        self.timing_engine = TimingEngine(self.config)
        self.progress_tracker = ProgressTracker()
        self.data_validator = DataValidator()
        
        # Initialize strategy (generated by /build-engine)
        self.strategy = GeneratedStrategy(self.config['strategy_parameters'])
        
        # Runtime state
        self.current_time = None
        self.ohlcv_data = {}
        self.features_data = {}
        self.backtest_results = {
            'trades': [],
            'events': [],
            'daily_series': [],
            'metadata': {}
        }
    
    def run(self, run_id: str) -> Dict[str, Any]:
        """
        Execute the complete backtest.
        
        Args:
            run_id: Unique identifier for this backtest run
            
        Returns:
            Dictionary containing backtest results and metadata
        """
        try:
            self.logger.info(f"Starting backtest run: {run_id}")
            
            # Phase 1: Data preparation
            self.progress_tracker.start_phase("Data Loading", 0.25)
            self._prepare_data()
            self.progress_tracker.complete_phase()
            
            # Phase 2: Signal generation and execution
            self.progress_tracker.start_phase("Backtest Execution", 0.65)
            self._run_backtest_loop()
            self.progress_tracker.complete_phase()
            
            # Phase 3: Results generation
            self.progress_tracker.start_phase("Results Generation", 0.10)
            results = self._generate_results(run_id)
            self.progress_tracker.complete_phase()
            
            self.logger.info(f"Backtest completed successfully: {run_id}")
            return results
            
        except Exception as e:
            self.logger.error(f"Backtest failed: {str(e)}")
            raise
    
    def _prepare_data(self) -> None:
        """Fetch and process all required data."""
        # Fetch raw OHLCV data
        self.ohlcv_data = self.data_fetcher.fetch_historical_data(
            symbols=self.config['universe']['symbols'],
            start_date=self.config['backtest']['start_date'],
            end_date=self.config['backtest']['end_date'],
            timeframe=self.config['timeframe']
        )
        
        # Process and validate data
        self.ohlcv_data = self.data_processor.process_ohlcv_data(self.ohlcv_data)
        self.data_validator.validate_ohlcv_data(self.ohlcv_data)
        
        # Calculate features if strategy requires them
        required_features = self.strategy.get_required_features()
        if required_features:
            self.features_data = self.data_processor.calculate_features(
                self.ohlcv_data, 
                required_features
            )
        
        self.logger.info(f"Data prepared: {len(self.ohlcv_data)} symbols, "
                        f"{len(next(iter(self.ohlcv_data.values())))} bars")
    
    def _run_backtest_loop(self) -> None:
        """Execute the main backtest simulation loop."""
        # Get all timestamps from the first symbol's data
        first_symbol = next(iter(self.ohlcv_data.keys()))
        timestamps = self.ohlcv_data[first_symbol].index
        
        warmup_periods = self.strategy.get_warmup_periods()
        start_idx = max(0, warmup_periods)
        
        total_bars = len(timestamps) - start_idx
        
        for i, timestamp in enumerate(timestamps[start_idx:], start_idx):
            self.current_time = timestamp
            progress = (i - start_idx) / total_bars
            self.progress_tracker.update_progress(progress)
            
            # Get current bar data for all symbols
            current_ohlcv = self._get_current_bar_data(timestamp)
            current_features = self._get_current_features_data(timestamp)
            
            # Update portfolio with current prices
            current_prices = {symbol: data['close'] for symbol, data in current_ohlcv.items()}
            self.portfolio_manager.update_prices(current_prices)
            
            # Process pending orders from previous bar
            if self.order_manager.has_pending_orders():
                filled_orders = self.order_manager.process_pending_orders(
                    current_ohlcv, self.fill_simulator, self.fee_calculator
                )
                for fill in filled_orders:
                    self.portfolio_manager.process_fill(fill)
                    self._record_trade(fill)
                    self.strategy.on_trade_filled(fill, self.portfolio_manager.get_state())
            
            # Generate new signals
            portfolio_state = self.portfolio_manager.get_state()
            signals = self.strategy.generate_signals(
                self.current_time, current_ohlcv, current_features, portfolio_state
            )
            
            # Process signals through risk management
            validated_signals = self.risk_manager.validate_signals(
                signals, portfolio_state, current_prices
            )
            
            # Convert signals to orders
            for signal in validated_signals:
                order = self._create_order_from_signal(signal, current_prices)
                if order:
                    self.order_manager.add_order(order)
                    self._record_event('signal_generated', signal)
            
            # Record daily portfolio state
            self._record_daily_state(timestamp, portfolio_state)
            
            # Call strategy end-of-bar hook
            self.strategy.on_bar_close(self.current_time, current_ohlcv, portfolio_state)
    
    def _get_current_bar_data(self, timestamp: pd.Timestamp) -> Dict[str, Dict[str, float]]:
        """Get OHLCV data for current timestamp."""
        current_data = {}
        for symbol, df in self.ohlcv_data.items():
            if timestamp in df.index:
                bar = df.loc[timestamp]
                current_data[symbol] = {
                    'open': bar['open'],
                    'high': bar['high'], 
                    'low': bar['low'],
                    'close': bar['close'],
                    'volume': bar['volume']
                }
        return current_data
    
    def _get_current_features_data(self, timestamp: pd.Timestamp) -> Dict[str, Dict[str, float]]:
        """Get features data for current timestamp."""
        if not self.features_data:
            return {}
        
        current_features = {}
        for symbol, df in self.features_data.items():
            if timestamp in df.index:
                current_features[symbol] = df.loc[timestamp].to_dict()
        return current_features
    
    def _create_order_from_signal(self, signal: Dict[str, Any], prices: Dict[str, float]) -> Optional[Dict[str, Any]]:
        """Convert a strategy signal into an order."""
        symbol = signal['symbol']
        if symbol not in prices:
            self.logger.warning(f"No price data for symbol {symbol}")
            return None
        
        current_price = prices[symbol]
        
        # Calculate position size if not specified
        quantity = signal.get('quantity')
        if quantity is None:
            quantity = self.strategy.calculate_position_size(
                signal, self.portfolio_manager.get_state(), current_price
            )
        
        if quantity == 0:
            return None
        
        order = {
            'symbol': symbol,
            'action': signal['action'],
            'quantity': quantity,
            'order_type': signal.get('order_type', 'market'),
            'limit_price': signal.get('limit_price'),
            'stop_loss': signal.get('stop_loss'),
            'take_profit': signal.get('take_profit'),
            'timestamp': self.current_time,
            'metadata': signal.get('metadata', {})
        }
        
        return order
    
    def _record_trade(self, fill: Dict[str, Any]) -> None:
        """Record a completed trade."""
        self.backtest_results['trades'].append(fill)
    
    def _record_event(self, event_type: str, data: Dict[str, Any]) -> None:
        """Record a backtest event."""
        event = {
            'timestamp': self.current_time,
            'type': event_type,
            'data': data
        }
        self.backtest_results['events'].append(event)
    
    def _record_daily_state(self, timestamp: pd.Timestamp, portfolio_state: Dict[str, Any]) -> None:
        """Record daily portfolio state."""
        daily_record = {
            'timestamp': timestamp,
            'equity': portfolio_state['total_equity'],
            'cash': portfolio_state['cash'],
            'positions_value': portfolio_state['positions_value'],
            'open_positions': len(portfolio_state['positions']),
            'daily_return': portfolio_state.get('daily_return', 0.0)
        }
        self.backtest_results['daily_series'].append(daily_record)
    
    def _generate_results(self, run_id: str) -> Dict[str, Any]:
        """Generate final backtest results."""
        # Calculate performance metrics
        final_state = self.portfolio_manager.get_state()
        
        results = {
            'run_id': run_id,
            'config': self.config,
            'start_time': self.config['backtest']['start_date'],
            'end_time': self.config['backtest']['end_date'],
            'final_equity': final_state['total_equity'],
            'total_trades': len(self.backtest_results['trades']),
            'trades': self.backtest_results['trades'],
            'events': self.backtest_results['events'],
            'daily_series': self.backtest_results['daily_series'],
            'portfolio_final_state': final_state,
            'metadata': {
                'engine_version': '1.0.0',
                'execution_time': datetime.now().isoformat(),
                'symbols_traded': list(self.ohlcv_data.keys())
            }
        }
        
        return results
    
    def _setup_logging(self) -> logging.Logger:
        """Setup logging for the backtest engine."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        return logging.getLogger(__name__)


if __name__ == "__main__":
    """Direct execution entry point for testing."""
    engine = BacktestEngine()
    run_id = f"test_run_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    results = engine.run(run_id)
    print(f"Backtest completed: {results['final_equity']}")